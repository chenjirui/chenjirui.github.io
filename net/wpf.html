<!DOCTYPE html>
<html lang="zh">

<head>
    <meta charset="utf-8" />
    <title>wpf学习</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" href="/style-base.css">
    <script type="text/javascript" src="https://ajax.microsoft.com/ajax/jquery/jquery-1.4.min.js">     </script>
    </script>
    <script type="text/javascript" src="/js-base.js">
    </script>
</head>

<body>
<main role="main">
    <h1>wpf学习</h1>
    
    <ul>
        <li><a href="#xaml">xaml</a></li>
        <li><a href="#application">Application</a></li>
        <li><a href="#window">窗体类</a></li>
        <li><a href="#layout">布局</a></li>
        <li><a href="wpf-controls.html">控件</a></li>
        <li><a href="#draw">绘图</a></li>
        <li><a href="#property">属性</a></li>
        <li><a href="#binding">Binding</a></li>
        <li><a href="#event">事件</a></li>
        <li><a href="#input">输入</a></li>
        <li><a href="#command">命令</a></li>
        <li><a href="#resource">资源</a></li>
        <li><a href="#style">样式</a></li>
        <li><a href="#template">模板</a></li>
        <li><a href="#trigger">触发器</a></li>
        <li><a href="#thread">线程处理模型</a></li>
        <li><a href="#globalization">全球化</a></li>
    </ul>

    <article>
        
        <section id="xaml">
            <h2>XAML</h2>
            <h3>对象元素</h3>
            <p>&lt;&gt;&lt;/&gt;<br>对象元素通常声明类型的实例<br></p>
        </section>
        
<section id="application">
    <h2>Application</h2>
    <h3>创建</h3>
    <p>Application app=new Application(); app.run();</p>
    <h3>关闭</h3>
    <ul>关闭模式 ShutdownMode
    <li>OnLastWindowClose 默认</li>
    <li>OnMainWindowClose</li>
    <li>OnExplicitShutdown 仅在调用Application.Shutdown()时结束</li></ul>
    <h3>生命周期</h3>
    <ol><li>Application.run()</li>
    <li>Startup</li>
    <li>Exit</li></ol>

</section>
        
        <section id="window">
            <p>

            </p>
        </section>
        
<section id="layout">
    <h2>布局</h2>
    <h3>测量和排列子控件</h3>
    <h3>Panel</h3>
    <p>Canvas:
        <br>使用相对于Canvas区域的坐标显式定位子元素</p>
    <p>DockPanel:
        <br>子元素互相水平或垂直排列</p>
    <p>Grid:
        <br>由行和列组成的网格</p>
    <p>StackPanel:
        <br>将子元素排列成一行(可沿水平或垂直方向)
    </p>
    <p>VirtualizingStackPanel:
        <br>将内容排列成一行(可沿水平或垂直方向),并使内容虚拟化</p>
    <p>WrapPanel:
        <br>从左至右按顺序位置定位子元素，在包含框的边缘处将内容断开至下一行。 后续排序按照从上至下或从右至左的顺序进行，具体取决于Orientation属性的值。
    </p>

</section>
        
<section id="draw">
    <h2>绘图</h2>
    <h3>形状</h3>
    <ul>Shape
        <li><dt>Line</dt>
            <dd>可以在坐标(X1,Y1)到(X2,Y2)之间绘制一条线</dd>
        </li>
        <li><dt>Rectangle</dt>
            <dd>通过指定Width 和Height 可以绘制一个矩形</dd>
        </li>
        <li><dt>Ellipse</dt>
            <dd>椭圆</dd>
        </li>
        <li><dt>Path</dt>
            <dd>使用Path 类可以绘制一系列直线和曲线。Data 属性是Geometry 类型。还可以使用派生自基类Geometry的类绘制图形，或使用路径标记语法来定义图形</dd>
        </li>
        <li><dt>Polygon</dt>
            <dd>绘制由线段连接而成的封闭图形。多边形由一系列赋予Points 属性的Point 对象定义</dd>
        </li>
        <li><dt>Polyline</dt>
            <dd>绘制连接起来的线段</dd>
        </li>
    </ul>
    <h3>变换</h3>
    <h3>画笔</h3>
    
<ul>
    <li>SolidColorBrush 纯色</li>
    <li>LinearGradientBrush 平滑的颜色变化</li>
    <li>RadialGradientBrush 以放射方式产生平滑的颜色渐变</li>
    <li>DrawingBrush 可以定义用画笔绘制的图形</li>
    <li>ImageBrush 把图像加载到画笔中</li>
    <li>VisualBrush 在画笔中使用其他WPF元素</li>
</ul>
    
</section>
        
<section id="property">
<h2>属性</h2>
<h3>依赖项属性</h3>
<em>基于其他输入的值计算属性值</em>
<p></p>
<h3>附加属性</h3>
</section>
       
        <section id="binding">
            <h2>数据绑定</h2>
            <h3>SetBinding</h3>
            <em>数据源</em>
            <pre><code>public class MyData : INotifyPropertyChanged
{
    //......
    
    public event PropertyChangedEventHandler PropertyChanged;
    private string myDataProperty;
    public String MyDataProperty
    {
        get { return myDataProperty; }
        set
        {
            myDataProperty = value;
            PropertyChangedEventHandler handler = PropertyChanged;
            if (handler != null)
            {
                handler(this, new PropertyChangedEventArgs("MyDataProperty"));
            }
        }
    }
}
</code></pre>
       <em>绑定</em>
       <pre><code>MyData myDataObject = new MyData();  
Binding myBinding = new Binding("MyDataProperty");
myBinding.Source = myDataObject;
myText.SetBinding(TextBlock.TextProperty, myBinding);
</code></pre>
       <em>清除绑定</em>
       <pre><code>BindingOperations.ClearBinding(myText, TextBlock.TextProperty);</code></pre>
        </section>
        
<section id="event">
    <h2>事件</h2>
    <h3>路由事件</h3>
    <h3>附加事件</h3>
</section>

<section id="input">
    <h2>输入</h2>
    <h3>Keyboard 键盘类</h3>
    <h3>Mouse 鼠标类</h3>
    <h3>Stylus 触笔类</h3>
    <h3>焦点</h3>
    <p><dt>键盘焦点:IsKeyboardFocused="true"</dt>
        <dd>KeyBoard.FocusedElement(),具有键盘焦点的元素
            <br>Keyboard.Focus(element),将键盘焦点给予element</dd>
    </p>
    <p><dt>(逻辑焦点)焦点范围:FocusManager.IsFocusScope="true"</dt>
        <dd>FocusManager.FocusedElement
            <br>FocusManager.SetIsFocusScope(element,true)
        </dd>
    </p>
</section>
       
<section id="command">
    <h2>命令</h2>
    <ul>命令模型:
        <li>命令是要执行的操作</li>
        <li>命令源是调用命令的对象</li>
        <li>命令目标是在其上执行命令的对象</li>
        <li>命令绑定是将命令逻辑映射到命令的对象</li>
    </ul>
    <h3>命令 实现ICommand接口 : RoutedCommand</h3>
    <ul>
        <li>Execute()在命令目标上引发PreviewExecuted和Executed事件</li>
        <li>CanExecute()在命令目标上引发CanExecute和PreviewCanExecute事件</li>
        <li>CanExecuteChanged</li>
    </ul>
    <h3>命令源 实现ICommandSource接口 : 控件,InputGesture</h3>
    <ul>
        <li>Command调用命令源时执行的命令</li>
        <li>CommandTarget执行命令的对象(ICommand是RoutedCommand时才适用)
            <br>CommandTarget="{Binding ElementName=elementName}"
            <br>如果未定义命令目标，则具有键盘焦点的元素将用作命令目标</li>
        <li>CommandParameter用户定义的数据类型</li>
    </ul>
    <h3>命令目标</h3>
    <h3>CommandBinding</h3>
    <ul>
        <li>Command与之关联的命令</li>
        <li>PreviewExecuted,Executed实现命令逻辑</li>
        <li>PreviewCanExecute,CanExecute确定命令是否可以在当前命令目标上执行。e.CanExecute = true;
        </li>
    </ul>
    <em>终止路由e.Handled=true;</em>
    
<h3>使用命令库</h3>
<p>&lt;CommandBinding Command="ApplicationCommands.New" Executed="NewCommandHandler" CanExecute="NewCanExecuteHandler" /&gt;
    <br>&lt;Button Command="ApplicationCommands.New"/&gt;</p>
<h3>使用自定义RoutedCommand</h3>
<p>public static RoutedCommand ExitRoutedCommand = new RoutedCommand();
    <br>&lt;CommandBinding Command="{x:Static local:MainWindow.ExitRoutedCommand}" Executed="ExitCommandHandler" CanExecute="ExitCanExecuteHandler" /&gt;
    <br>&lt;Button Command="ApplicationCommands.New"/&gt;</p>
</section>
        
<section id="resource">
    <h2>资源 预定义对象</h2>
    <h3>定义</h3>
    <pre><code>&lt;Xxx.Resources&gt;
    &lt;ClassName x:Key="myKey" attribute=value /&gt;
&lt;/Xxx.Resoures&gt;</code></pre> 
    <ol>
        <li>应用程序级资源 App.xaml Application.Resources</li>
        <li>窗体级资源 Window.xaml Window.Resources</li>
        <li>文件级资源 MyResourceDictionary.xaml ResourceDictionary</li>
        <li>对象（控件）级资源 ContentControl.Resources</li>
    </ol>
    <h3>使用</h3>
    <p>静态资源引用从控件所在的容器开始依次向上查找</p>
    <pre><code>"{StaticResource myKey}"</code></pre>
    <p>动态资源引用是从控件开始向上查找</p>
    <pre><code>"{DynamicResource myKey}"</code></pre>
    <h3>加载资源词典</h3>
    <pre><code>&lt;Application.Resources&gt;
    &lt;ResourceDictionary&gt;
        &lt;ResourceDictionary.MergedDictionaries&gt;
            &lt;ResourceDictionary Source="/ResourceLib;component/Dictionary1.xaml"/&gt;
        &lt;/ResourceDictionary.MergedDictionaries&gt;
    &lt;/ResourceDictionary&gt;
&lt;/Application.Resources&gt;</code></pre>
</section>
        
<section id="style">
    <h2>样式</h2>
    <pre><code>&lt;Style BaseOn="{StaticRsource {x:Type Xxx}}"
        TargetType="Xxx"
        x:Key="styleName"&gt;
        
    &lt;Setter Property="property" Value="val"/&gt;
    
    &lt;Setter Property="property"&gt;
        &lt;Setter.Value&gt;
            ...
        &lt;/Setter.Value&gt;
    &lt;Setter/&gt;
    
&lt;/Style&gt;</code></pre>

</section>
        
<section id="template">
    <h2>模板</h2>

    <h3>数据模板:数据(类,对象)的表现形式</h3>
    <pre><code>&lt;DataTemplate DataType="{x:type Xxx}"
        x:Key="temName"&gt;
    &lt;Element attribute="{Binding Xxx.Property}"
&lt;/DataTemplate&gt;</code></pre>

<h3>ControlTemplate控件模板:设置控件的外观</h3>
<h4>可视结构</h4>
<pre><code>&lt;ControlTemplate TargetType="Xxx" x:Key="XxxName"&gt;
    &lt;RootElement&gt;
        &lt;ContentPresenter /&gt;
    &lt;/RootElement&gt;</code></pre>
<h4>保留控件属性</h4>
<pre><code>attributeAlias="{TemplateBinding attribute}"</code></pre>
<h4>可视行为:控件处于特定状态时的控件外观</h4>
<pre><code>&lt;VisualState x:Name="ControlState"&gt;
    &lt;Storyboard&gt;
        &lt;ColorAnimation
            Storyboard.TargeetName="AttrName"
            Storyboard.TargetProperty="Color"
            To="Transparent"
            /&gt;
    &lt;/Storyboard&gt;
&lt;/VisualState&gt;</code></pre>
</section>

<section id="trigger">
    <h2>触发器</h2>
    <h3>属性触发器</h3>
    <pre><code>&lt;Style.Triggers&gt;
    &lt;Trigger Property="triggerPro" Value="true"&gt;
        &lt;Setter Property="controlPro" Value="val"/&gt;
    &lt;/Trigger&gt;
    
    ...
    
&lt;/Style.Triggers&gt;</code></pre>

<h3>事件触发器</h3>
<pre><code>&lt;EventTrigger RoutedEvent="Mouse.MouseEnter"&gt;
</code></pre>
</section>
  
<section id="thread">
    <h2>线程处理模型</h2>
    <p>WPF 应用程序从两个线程开始：一个用于处理呈现，一个用于管理 UI。呈现线程有效地隐藏在后台运行，而 UI 线程则接收输入、处理事件、绘制屏幕以及运行应用程序代码。</p>
    <p>UI 线程对一个名为 Dispatcher 的对象内的工作项进行排队。 Dispatcher 基于优先级选择工作项，并运行每一个工作项，直到完成。每个 UI 线程都必须至少有一个 Dispatcher，并且每个 Dispatcher 都只能在一个线程中执行工作项。</p>
    <p>Windows 只允许创建 UI 元素的线程访问这些元素。后台线程通过向 UI 线程的 Dispatcher 注册工作项来请求 UI 线程代表它执行操作。</p>
    <p>Dispatcher 类提供两个注册工作项的方法： Invoke 和 BeginInvoke。这两个方法均调度一个委托来执行。 Invoke 是同步调用，也就是说，直到 UI 线程实际执行完该委托它才返回。 BeginInvoke 是异步的，将立即返回。
    </p>
    <h3>辅助线程:利用UI线程空闲时间进行耗时计算</h3>
    <p>WPF线程模型不允许输入中断 UI 线程中正在进行的操作,必须定期返回到Dispatcher来处理挂起的输入事件</p>
    <ol>
        <li>创建委托
            <br>public delegate void NextPrimeDelegate();</li>
        <li>调用 BeginInvoke(DispatcherPriority, Delegate)
            <br>element.Dispatcher.BeginInvoke(DispatcherPriority.Normal,new NextPrimeDelegate(CheckNextNumber));</li>
    </ol>
    <h3>单独线程</h3>
    <ol>
        <li>创建委托
            <br>private delegate void NoArgDelegate();
        </li>
        <li>创建新线程
            <br>NoArgDelegate fetcher = new NoArgDelegate(this.FetchWeatherFromServer);
            <br>fetcher.BeginInvoke(null, null);</li>
        <li>更新UI
            <br>private void FetchWeatherFromServer() { ... element.Dispatcher.BeginInvoke(DispatcherPriority.Normal,new NoArgDelegate(UpdateUserInterface));}
        </li>
    </ol>
</section>
  
  <section id="globalization">
      <h2>全球化</h2>
      <h3>多语言用户界面</h3>
  </section>
   
    </article>
</main>

</body>
</html>